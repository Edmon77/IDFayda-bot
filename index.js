// Environment validation and configuration
const { validateEnv } = require('./config/env');
validateEnv();

// ---------- Keep process alive on unhandled errors (log and continue) ----------
const logger = require('./utils/logger');
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection at', { reason, stack: reason?.stack });
});
process.on('uncaughtException', (err) => {
  logger.error('Uncaught Exception', { message: err.message, stack: err.stack });
  // Don't exit - allow bot to keep serving other users (exit only on next fatal)
  // process.exit(1);
});

const express = require('express');
const crypto = require('crypto');
const helmet = require('helmet');
const session = require('express-session');
const MongoStore = require('connect-mongo');
const Captcha = require('2captcha');
const fayda = require('./utils/faydaClient');
const { Markup } = require('telegraf');

const bot = require('./bot');
const User = require('./models/User');
// auth middleware removed ‚Äî authorization is handled inline in bot.use()
const { connectDB, disconnectDB } = require('./config/database');
const { apiLimiter, checkUserRateLimit } = require('./utils/rateLimiter');
const { validateFaydaId, validateOTP, escMd, displayName } = require('./utils/validators');
const { parsePdfResponse } = require('./utils/pdfHelper');
const { BTN, getReplyKeyboard, getPanelTitle, paginate } = require('./utils/menu');
const { migrateRoles } = require('./utils/migrateRoles');
const pdfQueue = require('./queue');
const { safeResponseForLog } = require('./utils/logger');
const { DownloadTimer } = require('./utils/timer');

const PDF_SYNC_ATTEMPTS = 2;
const PDF_SYNC_RETRY_DELAY_MS = 2000;
const CAPTCHA_VERIFY_ATTEMPTS = 2;   // Retry on 500 (server) errors only ‚Äî abort on 400 (client) errors
const CAPTCHA_VERIFY_RETRY_DELAY_MS = 3000;
const VERIFICATION_COOLDOWN_MS = 2 * 60 * 1000; // 2 minutes between verification attempts

// Per-user download lock ‚Äî prevents concurrent downloads and webhook replay storms
const activeDownloads = new Map(); // telegramId ‚Üí true
// Per-user verification cooldown ‚Äî prevents OTP flood on Fayda API
const verificationCooldown = new Map(); // telegramId ‚Üí timestamp of last failure
// Lazy pre-solve: captcha solve starts when user taps Download, ready by the time they type their ID
const pendingCaptchas = new Map(); // telegramId ‚Üí Promise<string>

// ---------- Express App ----------
const app = express();
app.set('trust proxy', 1); // Trust first proxy (Railway / reverse proxy)

// Security headers
app.use(helmet({ contentSecurityPolicy: false })); // CSP disabled for EJS inline styles
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGODB_URI,
    ttl: 24 * 60 * 60 // 24 hours
  }),
  cookie: {
    maxAge: 1000 * 60 * 60 * 24,
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true
  }
}));
app.set('view engine', 'ejs');

// Simple session-based CSRF protection (no third-party library needed)
function csrfToken(req) {
  if (!req.session._csrf) {
    req.session._csrf = crypto.randomBytes(32).toString('hex');
  }
  return req.session._csrf;
}
function csrfProtection(req, res, next) {
  if (req.path === '/webhook') return next(); // Telegram webhook excluded
  if (req.method === 'POST') {
    const token = req.body._csrf || req.headers['x-csrf-token'];
    if (!token || token !== req.session._csrf) {
      return res.status(403).send('Invalid or missing CSRF token. Please refresh the page and try again.');
    }
  }
  next();
}
app.use(csrfProtection);
// Make CSRF token available to all EJS views
app.use((req, res, next) => {
  res.locals.csrfToken = csrfToken(req);
  next();
});

// Health check endpoint (simple ‚Äì for load balancers)
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// Deep health (MongoDB + Redis) ‚Äì for monitoring / zero-failure setups
const { redisClient } = require('./utils/rateLimiter');
app.get('/health/ready', async (req, res) => {
  const mongodb = await (async () => {
    try {
      const mongoose = require('mongoose');
      return mongoose.connection.readyState === 1 ? 'ok' : 'disconnected';
    } catch (e) {
      return 'error';
    }
  })();
  let redis = 'ok';
  try {
    await redisClient.ping();
  } catch (e) {
    redis = 'error';
  }
  const ok = mongodb === 'ok' && redis === 'ok';
  res.status(ok ? 200 : 503).json({
    status: ok ? 'ok' : 'degraded',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    mongodb,
    redis
  });
});

// Apply rate limiting to API routes
app.use('/api', apiLimiter);

// Login brute-force protection (5 attempts per 15 min per IP)
const loginLimiter = require('express-rate-limit')({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: 'Too many login attempts. Please try again later.',
  standardHeaders: true,
  legacyHeaders: false
});

// ---------- Web Dashboard (Admin Management) ----------
// Wrap async route handlers so thrown errors reach the Express error handler
const asyncHandler = (fn) => (req, res, next) => Promise.resolve(fn(req, res, next)).catch(next);

const requireWebAuth = (req, res, next) => {
  if (!process.env.ADMIN_USER || !process.env.ADMIN_PASS) return res.status(503).send('Admin dashboard not configured. Set ADMIN_USER and ADMIN_PASS.');
  if (req.session && req.session.admin) return next();
  res.redirect('/login');
};
app.get('/login', (req, res) => {
  if (!process.env.ADMIN_USER || !process.env.ADMIN_PASS) {
    return res.status(503).send('Admin dashboard not configured. Set ADMIN_USER and ADMIN_PASS in environment.');
  }
  res.render('login', { error: req.query.error });
});
app.post('/login', loginLimiter, (req, res) => {
  if (!process.env.ADMIN_USER || !process.env.ADMIN_PASS) {
    return res.status(503).send('Admin dashboard not configured.');
  }
  const { username, password } = req.body;
  // Timing-safe comparison to prevent timing attacks
  const userBuf = Buffer.from(String(username || ''));
  const passBuf = Buffer.from(String(password || ''));
  const expectedUserBuf = Buffer.from(process.env.ADMIN_USER);
  const expectedPassBuf = Buffer.from(process.env.ADMIN_PASS);
  const userMatch = userBuf.length === expectedUserBuf.length && crypto.timingSafeEqual(userBuf, expectedUserBuf);
  const passMatch = passBuf.length === expectedPassBuf.length && crypto.timingSafeEqual(passBuf, expectedPassBuf);
  if (userMatch && passMatch) {
    // Regenerate session to prevent session fixation
    req.session.regenerate((err) => {
      if (err) {
        logger.error('Session regeneration failed:', err);
        return res.render('login', { error: 'Server error. Try again.' });
      }
      req.session.admin = true;
      res.redirect('/dashboard');
    });
  } else {
    res.render('login', { error: 'Invalid credentials' });
  }
});
app.get('/logout', (req, res) => {
  req.session.destroy(() => {
    res.redirect('/login');
  });
});
app.get('/dashboard', requireWebAuth, asyncHandler(async (req, res) => {
  const admins = await User.find({ role: 'admin' }).sort({ createdAt: -1 }).lean();
  const allSubIds = admins.flatMap(b => b.subUsers || []);
  const subs = await User.find({ telegramId: { $in: allSubIds } }).select('telegramId downloadCount').lean();
  const subMap = new Map(subs.map(s => [s.telegramId, s.downloadCount || 0]));
  const revokedCount = await User.countDocuments({ role: 'admin', expiryDate: { $lt: new Date() } });
  const stats = {
    totalUsers: await User.countDocuments(),
    admins: admins.length,
    subUsers: allSubIds.length,
    expiringSoon: await User.countDocuments({ expiryDate: { $lt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), $gt: new Date() }, role: { $in: ['admin', 'user'] } }),
    totalDownloads: admins.reduce((s, b) => s + (b.downloadCount || 0) + (b.archivedSubDownloads || 0), 0) + subs.reduce((s, u) => s + (u.downloadCount || 0), 0),
    revokedCount
  };
  const enriched = admins.map(b => {
    const subIds = b.subUsers || [];
    const subDownloads = subIds.reduce((sum, id) => sum + (subMap.get(id) || 0), 0);
    const archived = b.archivedSubDownloads || 0;
    return { ...b, subDownloads, archived, totalDownloads: (b.downloadCount || 0) + subDownloads + archived };
  });
  res.render('dashboard', { stats, admins: enriched, error: req.query.error });
}));
app.get('/pending', requireWebAuth, asyncHandler(async (req, res) => {
  const pending = await User.find({ role: 'unauthorized' }).sort({ lastActive: -1 }).limit(50).lean();
  res.render('pending', { pending });
}));
app.post('/add-buyer', requireWebAuth, asyncHandler(async (req, res) => {
  const { telegramId, expiryDays = 30 } = req.body;
  if (!telegramId || !/^\d+$/.test(String(telegramId).trim())) {
    return res.redirect('/dashboard?error=invalid_id');
  }
  const tid = String(telegramId).trim();
  let user = await User.findOne({ telegramId: tid });
  if (!user) {
    return res.redirect('/dashboard?error=user_must_start');
  }
  if (user.role === 'admin') {
    return res.redirect('/dashboard?error=already_added');
  }
  if (user.addedBy) await User.updateOne({ telegramId: user.addedBy }, { $pull: { subUsers: tid } });
  const expiry = new Date();
  expiry.setDate(expiry.getDate() + (parseInt(expiryDays) || 30));
  user.role = 'admin';
  user.addedBy = undefined;
  user.expiryDate = expiry;
  user.subUsers = [];
  await user.save();
  try {
    await bot.telegram.sendMessage(tid, "‚úÖ Your access has been activated!", { parse_mode: 'Markdown' });
    await bot.telegram.sendMessage(tid, getPanelTitle('admin'), { parse_mode: 'Markdown', ...getReplyKeyboard('admin') });
  } catch (e) { logger.warn('Could not notify new admin:', e.message); }
  res.redirect('/dashboard');
}));
app.get('/buyer/:id', requireWebAuth, asyncHandler(async (req, res) => {
  const buyer = await User.findOne({ telegramId: req.params.id });
  if (!buyer) return res.status(404).send('Not found');
  const subs = await User.find({ telegramId: { $in: buyer.subUsers || [] } }).lean();
  const subUsersTotal = subs.reduce((s, u) => s + (u.downloadCount || 0), 0);
  const archived = buyer.archivedSubDownloads || 0;
  const totalDownloads = (buyer.downloadCount || 0) + subUsersTotal + archived;
  res.render('buyer-detail', { buyer, subs, buyerOwn: buyer.downloadCount || 0, subUsersTotal, archived, totalDownloads, error: req.query.error });
}));
app.post('/buyer/:id/add-sub', requireWebAuth, asyncHandler(async (req, res) => {
  const { identifier, expiryDays } = req.body;
  const tid = String(identifier).trim().replace(/\s/g, '');
  if (!/^\d+$/.test(tid)) return res.redirect(`/buyer/${req.params.id}?error=invalid_id`);
  const buyer = await User.findOne({ telegramId: req.params.id });
  if (!buyer) return res.redirect('/dashboard');
  let subUser = await User.findOne({ telegramId: tid });
  if (!subUser) return res.redirect(`/buyer/${req.params.id}?error=must_start`);
  if (subUser.role === 'admin') return res.redirect(`/buyer/${req.params.id}?error=already_admin`);
  if ((buyer.subUsers || []).length >= 9) return res.redirect(`/buyer/${req.params.id}?error=full`);
  if ((buyer.subUsers || []).includes(tid)) return res.redirect(`/buyer/${req.params.id}?error=already`);
  buyer.subUsers = buyer.subUsers || [];
  buyer.subUsers.push(tid);
  await buyer.save();
  subUser.role = 'user';
  subUser.addedBy = buyer.telegramId;
  subUser.parentAdmin = buyer.telegramId;
  const days = parseInt(expiryDays) || 30;
  const subExpiry = new Date();
  subExpiry.setDate(subExpiry.getDate() + days);
  subUser.expiryDate = subExpiry;

  await subUser.save();
  try {
    await bot.telegram.sendMessage(tid, "‚úÖ Your access has been activated!", { parse_mode: 'Markdown' });
    await bot.telegram.sendMessage(tid, getPanelTitle('user'), { parse_mode: 'Markdown', ...getReplyKeyboard('user') });
  } catch (e) { logger.warn('Could not notify new sub-user:', e.message); }
  res.redirect(`/buyer/${req.params.id}`);
}));
app.post('/buyer/:buyerId/remove-sub/:subId', requireWebAuth, asyncHandler(async (req, res) => {
  // Archive sub-user downloads before deletion so billing total is preserved
  const sub = await User.findOne({ telegramId: req.params.subId }).select('downloadCount').lean();
  const dlCount = sub?.downloadCount || 0;
  await User.updateOne({ telegramId: req.params.buyerId }, {
    $pull: { subUsers: req.params.subId },
    $inc: { archivedSubDownloads: dlCount }
  });
  await User.deleteOne({ telegramId: req.params.subId });
  res.redirect(`/buyer/${req.params.buyerId}`);
}));
app.post('/buyer/:id/remove', requireWebAuth, asyncHandler(async (req, res) => {
  const buyer = await User.findOne({ telegramId: req.params.id });
  if (!buyer) return res.redirect('/dashboard');
  // Archive sub-user downloads before demoting admin
  if (buyer.subUsers && buyer.subUsers.length > 0) {
    const subs = await User.find({ telegramId: { $in: buyer.subUsers } }).select('downloadCount').lean();
    const totalSubDl = subs.reduce((sum, s) => sum + (s.downloadCount || 0), 0);
    buyer.archivedSubDownloads = (buyer.archivedSubDownloads || 0) + totalSubDl;
  }
  buyer.role = 'unauthorized';
  buyer.addedBy = undefined;
  buyer.expiryDate = undefined;
  buyer.subUsers = [];
  await buyer.save();
  await User.updateMany({ addedBy: req.params.id }, { role: 'unauthorized', addedBy: undefined, parentAdmin: undefined, expiryDate: undefined });
  res.redirect('/dashboard');
}));

// ---------- Clear Download Summary ----------
app.post('/buyer/:id/clear-downloads', requireWebAuth, asyncHandler(async (req, res) => {
  const buyer = await User.findOne({ telegramId: req.params.id });
  if (!buyer) return res.redirect('/dashboard');
  // Reset admin's own + archived counts
  buyer.downloadCount = 0;
  buyer.archivedSubDownloads = 0;
  await buyer.save();
  // Reset all current sub-users' counts
  if (buyer.subUsers && buyer.subUsers.length > 0) {
    await User.updateMany(
      { telegramId: { $in: buyer.subUsers } },
      { $set: { downloadCount: 0 } }
    );
  }
  res.redirect(`/buyer/${req.params.id}`);
}));

// ---------- Revoked Admins Page ----------
app.get('/revoked', requireWebAuth, asyncHandler(async (req, res) => {
  const revoked = await User.find({
    role: 'admin',
    expiryDate: { $lt: new Date() }
  }).sort({ expiryDate: -1 }).lean();
  // Enrich with sub-user info and download totals
  const allSubIds = revoked.flatMap(b => b.subUsers || []);
  const subs = await User.find({ telegramId: { $in: allSubIds } }).select('telegramId downloadCount').lean();
  const subMap = new Map(subs.map(s => [s.telegramId, s.downloadCount || 0]));
  const enriched = revoked.map(b => {
    const subDownloads = (b.subUsers || []).reduce((sum, id) => sum + (subMap.get(id) || 0), 0);
    const archived = b.archivedSubDownloads || 0;
    return { ...b, subDownloads, archived, totalDownloads: (b.downloadCount || 0) + subDownloads + archived };
  });
  res.render('revoked', { revoked: enriched });
}));

// ---------- Restore Revoked Admin ----------
app.post('/buyer/:id/restore', requireWebAuth, asyncHandler(async (req, res) => {
  const { expiryDays = 30 } = req.body;
  const buyer = await User.findOne({ telegramId: req.params.id });
  if (!buyer) return res.redirect('/revoked');
  // Only restore if actually expired
  if (buyer.expiryDate && new Date(buyer.expiryDate) >= new Date()) {
    return res.redirect('/revoked');
  }
  const expiry = new Date();
  expiry.setDate(expiry.getDate() + (parseInt(expiryDays) || 30));
  buyer.expiryDate = expiry;
  await buyer.save();
  // Also update sub-users' expiry to match
  if (buyer.subUsers && buyer.subUsers.length > 0) {
    await User.updateMany(
      { telegramId: { $in: buyer.subUsers } },
      { $set: { expiryDate: expiry } }
    );
  }
  // Notify admin via Telegram
  try {
    await bot.telegram.sendMessage(buyer.telegramId, '‚úÖ Your access has been restored!', { parse_mode: 'Markdown' });
    await bot.telegram.sendMessage(buyer.telegramId, getPanelTitle('admin'), { parse_mode: 'Markdown', ...getReplyKeyboard('admin') });
  } catch (e) {
    logger.warn('Could not notify restored admin:', e.message);
  }
  // Notify sub-users via Telegram
  for (const subId of (buyer.subUsers || [])) {
    try {
      await bot.telegram.sendMessage(subId, '‚úÖ Your access has been restored!', { parse_mode: 'Markdown' });
      await bot.telegram.sendMessage(subId, getPanelTitle('user'), { parse_mode: 'Markdown', ...getReplyKeyboard('user') });
    } catch (e) {
      logger.warn(`Could not notify restored sub-user ${subId}:`, e.message);
    }
  }
  res.redirect('/revoked');
}));
app.get('/export-users', requireWebAuth, asyncHandler(async (req, res) => {
  const users = await User.find({}).lean();
  function csvEscape(val) {
    const s = String(val ?? '');
    return s.includes(',') || s.includes('"') || s.includes('\n') ? `"${s.replace(/"/g, '""')}"` : s;
  }
  let csv = 'Telegram ID,Role,Name,Username,Expiry,Last Active,Downloads,Archived Downloads\n';
  users.forEach(u => {
    csv += `${u.telegramId},${u.role},${csvEscape((u.firstName || '') + ' ' + (u.lastName || ''))},@${u.telegramUsername || ''},${u.expiryDate || ''},${u.lastActive || ''},${u.downloadCount || 0},${u.archivedSubDownloads || 0}\n`;
  });
  res.setHeader('Content-Type', 'text/csv');
  res.attachment('users.csv');
  res.send(csv);
}));

// ---------- Global Express Error Handler ----------
app.use((err, req, res, _next) => {
  logger.error('Unhandled web error:', { message: err.message, stack: err.stack, path: req.path });
  res.status(500).send('Something went wrong. Please try again later.');
});

// ---------- Constants ----------
// API_BASE removed ‚Äî accessed directly via fayda.api
const SITE_KEY = process.env.CAPTCHA_SITE_KEY || "6LcSAIwqAAAAAGsZElBPqf63_0fUtp17idU-SQYC";
const HEADERS = fayda.HEADERS;
const solver = new Captcha.Solver(process.env.CAPTCHA_KEY);

const PREFER_QUEUE_PDF = process.env.PREFER_QUEUE_PDF === 'true' || process.env.PREFER_QUEUE_PDF === '1';

// ---------- Error Handler Middleware ----------
bot.catch((err, ctx) => {
  // Ignore common Telegram errors that don't need action
  const ignorableErrors = [
    'bot was blocked by the user',
    'chat not found',
    'user is deactivated',
    'bot was kicked from the group',
    'message to delete not found',
    'message is not modified'
  ];

  const isIgnorable = ignorableErrors.some(msg => err.message?.toLowerCase().includes(msg.toLowerCase()));

  if (isIgnorable) {
    // Log but don't try to send message (user blocked bot or chat doesn't exist)
    logger.warn(`Ignoring Telegram error: ${err.message}`);
    return;
  }

  // Log other errors
  logger.error('Bot error:', {
    error: err.message,
    stack: err.stack,
    update: ctx.update
  });

  // Don't send error messages for handler timeouts ‚Äî the handler likely
  // already completed successfully (e.g., PDF delivered) before the timeout fired.
  if (err.name === 'TimeoutError' || err.message?.includes('timed out')) {
    return;
  }

  // Try to send error message only if we have a valid context and chat
  if (ctx && ctx.chat && ctx.from) {
    try {
      ctx.reply('‚ùå An error occurred. Please try again later or contact support.').catch(() => {
        // Silently ignore if we can't send (user blocked, etc.)
      });
    } catch (e) {
      // Silently ignore errors sending error messages
    }
  }
});

// ---------- Upsert User + Authorization + Rate Limiting (single DB query) ----------
bot.use(async (ctx, next) => {
  if (!ctx.from) return next();
  try {
    const telegramId = ctx.from.id.toString();

    // Rate limit check
    const rateLimit = await checkUserRateLimit(telegramId, 30, 60000);
    if (!rateLimit.allowed) {
      const waitTime = rateLimit.resetTime ? Math.ceil((rateLimit.resetTime - Date.now()) / 1000) : 60;
      return ctx.reply(`‚è≥ Too many requests. Please wait ${waitTime} seconds.`);
    }

    // Single DB call: upsert profile + return current doc (replaces two separate queries)
    const user = await User.findOneAndUpdate(
      { telegramId },
      {
        $set: {
          firstName: ctx.from.first_name,
          lastName: ctx.from.last_name,
          telegramUsername: ctx.from.username,
          lastActive: new Date()
        },
        $inc: { usageCount: 1 },
        $setOnInsert: { role: 'unauthorized', createdAt: new Date() }
      },
      { upsert: true, new: true }
    );

    if (!user || user.role === 'unauthorized') {
      return ctx.reply(
        `‚ùå Access Denied\n\nYour Telegram ID: \`${telegramId}\`\n\nSend this ID to an admin to purchase access.`,
        { parse_mode: 'Markdown', ...Markup.removeKeyboard() }
      );
    }

    if (user.expiryDate && new Date(user.expiryDate) < new Date()) {
      if (user.role === 'admin') {
        return ctx.reply('‚ùå Access Revoked, Pay Your Credits !!', Markup.removeKeyboard());
      }
      return ctx.reply('‚ùå Access Revoked, Contact Admin!!', Markup.removeKeyboard());
    }

    // If sub-user, also check if parent admin is expired/revoked
    if (user.role === 'user' && user.parentAdmin) {
      const parentAdmin = await User.findOne(
        { telegramId: user.parentAdmin },
        { expiryDate: 1, role: 1 }
      ).lean();
      if (!parentAdmin || parentAdmin.role === 'unauthorized' ||
        (parentAdmin.expiryDate && new Date(parentAdmin.expiryDate) < new Date())) {
        return ctx.reply('‚ùå Access Revoked, Contact Admin!!', Markup.removeKeyboard());
      }
    }

    ctx.state.user = user;
    return next();
  } catch (error) {
    logger.error('Authorization middleware error:', error);
    return ctx.reply('‚ùå An error occurred. Please try again.');
  }
});

// ---------- Role Guard Helper ----------
function isAdmin(ctx) {
  return ctx.state.user && ctx.state.user.role === 'admin';
}
async function adminGuard(ctx) {
  if (!isAdmin(ctx)) {
    try { await ctx.answerCbQuery('‚ùå Access denied ‚Äî admin only.'); } catch (_) { }
    return false;
  }
  return true;
}


// ---------- Start Command ‚Äì Show Reply Keyboard ----------
bot.start(async (ctx) => {
  try {
    ctx.session = ctx.session || {};
    ctx.session.step = null;
    const user = ctx.state.user;
    const title = getPanelTitle(user.role);
    await ctx.reply(title, {
      parse_mode: 'Markdown',
      ...getReplyKeyboard(user.role)
    });
  } catch (error) {
    logger.error('Start command error:', error);
    ctx.reply('‚ùå Failed to load menu. Please try again.').catch(() => { });
  }
});

// ---------- Cancel Handler (shared by /cancel command) ----------
async function handleCancel(ctx) {
  ctx.session = ctx.session || {};
  ctx.session.step = null;
  // Release download lock so user can start fresh
  activeDownloads.delete(ctx.from.id.toString());
  await ctx.reply('‚ùå Cancelled.');
}

bot.command('cancel', async (ctx) => {
  try {
    await handleCancel(ctx);
  } catch (error) {
    logger.error('Cancel command error:', error);
  }
});

// ---------- Download Handler (shared by inline button and reply keyboard) ----------
async function handleDownload(ctx, isInline) {
  ctx.session = ctx.session || {};
  // If user already has a download in progress, don't reset their session
  const userId = ctx.from.id.toString();
  if (activeDownloads.has(userId)) {
    const msg = '‚è≥ You already have a download in progress. Please wait.';
    if (isInline) {
      await ctx.answerCbQuery(msg, { show_alert: true }).catch(() => { });
    } else {
      await ctx.reply(msg);
    }
    return;
  }
  ctx.session.step = 'ID';

  // Lazy pre-solve: start captcha solve NOW while user types their ID (5-15s of free overlap)
  pendingCaptchas.set(userId, solver.recaptcha(SITE_KEY, 'https://resident.fayda.et/').then(r => r.data).catch(err => {
    logger.warn('Pre-solve captcha failed, will solve on-demand', { error: err.message });
    return null; // null signals fallback to on-demand
  }));

  const text = "üöÄ Fayda ID Downloader\nPlease enter your **FCN/FIN number** (16 or 12 digits):";
  if (isInline) {
    await ctx.editMessageText(text, { parse_mode: 'Markdown' });
  } else {
    await ctx.reply(text, { parse_mode: 'Markdown' });
  }
}

bot.action('download', async (ctx) => {
  try {
    await ctx.answerCbQuery();
    await handleDownload(ctx, true);
  } catch (error) {
    logger.error('Download action error:', error);
    ctx.reply('‚ùå Failed to start download. Please try again.').catch(() => { });
  }
});

// ---------- Back to Main Menu (inline button) ----------
bot.action('main_menu', async (ctx) => {
  try {
    await ctx.answerCbQuery();
    ctx.session = ctx.session || {};
    ctx.session.step = null;
    const user = ctx.state.user;
    const title = getPanelTitle(user.role);
    // Remove inline buttons from the old message ‚Äî reply keyboard is persistent
    await ctx.editMessageText(title, { parse_mode: 'Markdown' });
  } catch (error) {
    logger.error('Main menu action error:', error);
  }
});



// ---------- Admin: View Admins (paginated 10 per page) ----------
bot.action(/view_admins_page_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    const page = parseInt(ctx.match[1], 10);
    const admins = await User.find({ role: 'admin' }).sort({ createdAt: -1 }).select('telegramId firstName telegramUsername subUsers').lean();
    const { items: pageAdmins, page: p, totalPages } = paginate(admins, page);
    let text = 'üëë **Your Admins** (Page ' + p + '/' + totalPages + '):\n\n';
    pageAdmins.forEach((a, i) => {
      const count = (a.subUsers || []).length;
      text += `${(page - 1) * 10 + i + 1}. ${escMd(a.firstName) || 'N/A'} (@${escMd(a.telegramUsername) || 'N/A'})\n`;
      text += `   ID: \`${a.telegramId}\`\n   Users: ${count}\n\n`;
    });
    const btns = [];
    if (totalPages > 1) {
      const row = [];
      if (p > 1) row.push(Markup.button.callback('‚èÆÔ∏è Previous', `view_admins_page_${p - 1}`));
      if (p < totalPages) row.push(Markup.button.callback('‚è≠Ô∏è Next', `view_admins_page_${p + 1}`));
      if (row.length) btns.push(row);
    }
    btns.push([Markup.button.callback('üîô Back', 'manage_users')]);
    await ctx.editMessageText(text, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: btns } });
  } catch (error) {
    logger.error('View admins error:', error);
    ctx.reply('‚ùå An error occurred. Please try again.').catch(() => { });
  }
});

// ---------- Admin: View My Users (paginated 10 per page) ----------
bot.action(/view_my_users_page_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    const admin = ctx.state.user;
    const userIds = admin.subUsers || [];
    const users = await User.find({ telegramId: { $in: userIds } }).select('telegramId firstName telegramUsername downloadCount').lean();
    const page = parseInt(ctx.match[1], 10);
    const { items: pageUsers, page: p, totalPages } = paginate(users, page);
    let text = 'üõ† **Your Users** (Page ' + p + '/' + totalPages + '):\n\n';
    pageUsers.forEach((u, i) => {
      text += `${(page - 1) * 10 + i + 1}. ${escMd(u.firstName) || 'N/A'} (@${escMd(u.telegramUsername) || 'N/A'})\n`;
      text += `   ID: \`${u.telegramId}\`\n   PDFs: ${u.downloadCount || 0}\n\n`;
    });
    const btns = [];
    if (totalPages > 1) {
      const row = [];
      if (p > 1) row.push(Markup.button.callback('‚èÆÔ∏è Previous', `view_my_users_page_${p - 1}`));
      if (p < totalPages) row.push(Markup.button.callback('‚è≠Ô∏è Next', `view_my_users_page_${p + 1}`));
      if (row.length) btns.push(row);
    }
    btns.push([Markup.button.callback('üîô Back', 'manage_users')]);
    await ctx.editMessageText(text, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: btns } });
  } catch (error) {
    logger.error('View my users error:', error);
    ctx.reply('‚ùå An error occurred. Please try again.').catch(() => { });
  }
});

// ---------- Admin: Remove Admin list (paginated) ----------
bot.action(/remove_admin_list_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    const page = parseInt(ctx.match[1], 10);
    const admins = await User.find({ role: 'admin' }).sort({ createdAt: -1 }).select('telegramId firstName telegramUsername subUsers').lean();
    const { items: pageAdmins, page: p, totalPages } = paginate(admins, page);
    if (!pageAdmins.length) {
      await ctx.editMessageText('‚ùå No admins to remove.', Markup.inlineKeyboard([[Markup.button.callback('üîô Back', 'manage_users')]]));
      return;
    }
    let text = '**Select an admin to remove:**\n\n';
    pageAdmins.forEach((a, i) => {
      text += `${(page - 1) * 10 + i + 1}. ${escMd(a.firstName) || 'N/A'} (@${escMd(a.telegramUsername) || 'N/A'}) ‚Äì ID: \`${a.telegramId}\`\n`;
    });
    const btns = pageAdmins.map(a => [Markup.button.callback(`‚ùå Remove ${escMd(a.firstName) || a.telegramId}`, `remove_buyer_${a.telegramId}`)]);
    if (totalPages > 1) {
      const row = [];
      if (p > 1) row.push(Markup.button.callback('‚èÆÔ∏è Previous', `remove_admin_list_${p - 1}`));
      if (p < totalPages) row.push(Markup.button.callback('‚è≠Ô∏è Next', `remove_admin_list_${p + 1}`));
      btns.push(row);
    }
    btns.push([Markup.button.callback('üîô Back', 'manage_users')]);
    await ctx.editMessageText(text, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: btns } });
  } catch (error) {
    logger.error('Remove admin list error:', error);
    ctx.reply('‚ùå An error occurred. Please try again.').catch(() => { });
  }
});

// ---------- Admin: Remove User list (paginated) ----------
bot.action(/remove_my_user_list_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    const admin = ctx.state.user;
    const userIds = admin.subUsers || [];
    const users = await User.find({ telegramId: { $in: userIds } }).select('telegramId firstName telegramUsername').lean();
    const page = parseInt(ctx.match[1], 10);
    const { items: pageUsers, page: p, totalPages } = paginate(users, page);
    if (!pageUsers.length) {
      await ctx.editMessageText('‚ùå No users to remove.', Markup.inlineKeyboard([[Markup.button.callback('üîô Back', 'manage_users')]]));
      return;
    }
    let text = '**Select a user to remove:**\n\n';
    pageUsers.forEach((u, i) => {
      text += `${(page - 1) * 10 + i + 1}. ${escMd(u.firstName) || 'N/A'} (@${escMd(u.telegramUsername) || 'N/A'}) ‚Äì ID: \`${u.telegramId}\`\n`;
    });
    const btns = pageUsers.map(u => [Markup.button.callback(`‚ùå Remove ${escMd(u.firstName) || u.telegramId}`, `remove_my_sub_${u.telegramId}`)]);
    if (totalPages > 1) {
      const row = [];
      if (p > 1) row.push(Markup.button.callback('‚èÆÔ∏è Previous', `remove_my_user_list_${p - 1}`));
      if (p < totalPages) row.push(Markup.button.callback('‚è≠Ô∏è Next', `remove_my_user_list_${p + 1}`));
      btns.push(row);
    }
    btns.push([Markup.button.callback('üîô Back', 'manage_users')]);
    await ctx.editMessageText(text, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: btns } });
  } catch (error) {
    logger.error('Remove my user list error:', error);
    ctx.reply('‚ùå An error occurred. Please try again.').catch(() => { });
  }
});

// ---------- Admin: Add User Under Admin (start flow) ----------
bot.action('add_user_under_admin', async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    ctx.session = { ...ctx.session, step: 'AWAITING_ADMIN_ID_FOR_USER' };
    await ctx.editMessageText(
      'üìù **Add User Under Admin**\n\nSend the **Telegram ID** of the **admin** (e.g. \`358404165\`).\n\n_They must already be an admin._',
      { parse_mode: 'Markdown', ...Markup.inlineKeyboard([[Markup.button.callback('üîô Cancel', 'manage_users')]]) }
    );
  } catch (error) {
    logger.error('Add user under admin error:', error);
    ctx.reply('‚ùå An error occurred. Please try again.').catch(() => { });
  }
});

// ---------- Admin: Remove User Under Admin (list admins, then pick user) ----------
bot.action('remove_user_under_admin', async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    const admins = await User.find({ role: 'admin' }).sort({ createdAt: -1 }).select('telegramId firstName telegramUsername subUsers').lean();
    const { items: pageAdmins, page: p, totalPages } = paginate(admins, 1);
    if (!pageAdmins.length) {
      await ctx.editMessageText('‚ùå No admins.', Markup.inlineKeyboard([[Markup.button.callback('üîô Back', 'manage_users')]]));
      return;
    }
    let text = '**Select the admin whose user you want to remove:**\n\n';
    pageAdmins.forEach((a, i) => {
      text += `${i + 1}. ${escMd(a.firstName) || 'N/A'} (@${escMd(a.telegramUsername) || 'N/A'}) ‚Äì ID: \`${a.telegramId}\`\n`;
    });
    const btns = pageAdmins.map(a => [Markup.button.callback(`${a.firstName || a.telegramId}`, `remove_under_admin_${a.telegramId}_1`)]);
    if (totalPages > 1) btns.push([Markup.button.callback('‚è≠Ô∏è Next', `remove_under_admin_list_2`)]);
    btns.push([Markup.button.callback('üîô Back', 'manage_users')]);
    await ctx.editMessageText(text, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: btns } });
  } catch (error) {
    logger.error('Remove user under admin error:', error);
    ctx.reply('‚ùå An error occurred. Please try again.').catch(() => { });
  }
});

bot.action(/remove_under_admin_(\d+)_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    const adminId = ctx.match[1];
    const page = parseInt(ctx.match[2], 10);
    const admin = await User.findOne({ telegramId: adminId }).lean();
    if (!admin) {
      return ctx.editMessageText('‚ùå Admin not found.', Markup.inlineKeyboard([[Markup.button.callback('üîô Back', 'manage_users')]]));
    }
    const userIds = admin.subUsers || [];
    const users = await User.find({ telegramId: { $in: userIds } }).select('telegramId firstName telegramUsername').lean();
    const { items: pageUsers, page: p, totalPages } = paginate(users, page);
    if (!pageUsers.length) {
      return ctx.editMessageText('‚ùå This admin has no users.', Markup.inlineKeyboard([[Markup.button.callback('üîô Back', 'remove_user_under_admin')]]));
    }
    let text = `**Remove user under ${escMd(admin.firstName) || admin.telegramId}:**\n\n`;
    pageUsers.forEach((u, i) => {
      text += `${(page - 1) * 10 + i + 1}. ${escMd(u.firstName) || 'N/A'} (@${escMd(u.telegramUsername) || 'N/A'}) ‚Äì ID: \`${u.telegramId}\`\n`;
    });
    const btns = pageUsers.map(u => [Markup.button.callback(`‚ùå ${escMd(u.firstName) || u.telegramId}`, `remove_sub_${adminId}_${u.telegramId}`)]);
    if (totalPages > 1) {
      const row = [];
      if (p > 1) row.push(Markup.button.callback('‚èÆÔ∏è Previous', `remove_under_admin_${adminId}_${p - 1}`));
      if (p < totalPages) row.push(Markup.button.callback('‚è≠Ô∏è Next', `remove_under_admin_${adminId}_${p + 1}`));
      btns.push(row);
    }
    btns.push([Markup.button.callback('üîô Back', 'remove_user_under_admin')]);
    await ctx.editMessageText(text, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: btns } });
  } catch (error) {
    logger.error('Remove under admin error:', error);
    ctx.reply('‚ùå An error occurred. Please try again.').catch(() => { });
  }
});

bot.action(/remove_under_admin_list_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    const page = parseInt(ctx.match[1], 10);
    const admins = await User.find({ role: 'admin' }).sort({ createdAt: -1 }).select('telegramId firstName telegramUsername').lean();
    const { items: pageAdmins, page: p, totalPages } = paginate(admins, page);
    let text = '**Select the admin whose user you want to remove:**\n\n';
    pageAdmins.forEach((a, i) => {
      text += `${(page - 1) * 10 + i + 1}. ${escMd(a.firstName) || 'N/A'} (@${escMd(a.telegramUsername) || 'N/A'}) ‚Äì ID: \`${a.telegramId}\`\n`;
    });
    const btns = pageAdmins.map(a => [Markup.button.callback(`${a.firstName || a.telegramId}`, `remove_under_admin_${a.telegramId}_1`)]);
    if (totalPages > 1) {
      const row = [];
      if (p > 1) row.push(Markup.button.callback('‚èÆÔ∏è Previous', `remove_under_admin_list_${p - 1}`));
      if (p < totalPages) row.push(Markup.button.callback('‚è≠Ô∏è Next', `remove_under_admin_list_${p + 1}`));
      btns.push(row);
    }
    btns.push([Markup.button.callback('üîô Back', 'manage_users')]);
    await ctx.editMessageText(text, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: btns } });
  } catch (e) {
    logger.error('Remove under admin list error:', e);
  }
});

// ---------- Admin: View Sub Users for an Admin ----------
bot.action(/subusers_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    const buyerId = ctx.match[1];
    const buyer = await User.findOne({ telegramId: buyerId }).lean();
    if (!buyer) {
      return ctx.editMessageText('‚ùå User not found.', Markup.inlineKeyboard([[Markup.button.callback('üîô Back', 'dashboard_buyer')]]));
    }
    const subs = await User.find({ telegramId: { $in: buyer.subUsers || [] } })
      .select('telegramId firstName telegramUsername downloadCount')
      .lean()
      .exec();

    let text = `**Sub Users**\n`;
    text += `_${escMd(buyer.firstName) || buyer.telegramId} (@${escMd(buyer.telegramUsername) || 'N/A'})_\n\n`;
    subs.forEach((sub, i) => {
      text += `${i + 1}. **${displayName(sub)}** (@${escMd(sub.telegramUsername) || 'N/A'})\n`;
      text += `   ID: \`${sub.telegramId}\` | PDFs: ${sub.downloadCount || 0}\n`;
    });

    const buttons = subs.map(sub => [Markup.button.callback(`‚ùå Remove ${displayName(sub)}`, `remove_sub_${buyerId}_${sub.telegramId}`)]);
    buttons.push([Markup.button.callback('üîô Back to Dashboard', 'dashboard_buyer')]);
    await ctx.editMessageText(text, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: buttons } });
  } catch (error) {
    logger.error('Sub users view error:', error);
    ctx.reply('‚ùå Failed. Please try again.');
  }
});

// ---------- Dashboard Handler (shared by inline button and reply keyboard) ----------
async function handleDashboard(ctx, isInline) {
  const buyer = ctx.state.user;
  if (!buyer || buyer.role !== 'admin') return;

  const subs = await User.find({ telegramId: { $in: buyer.subUsers || [] } })
    .select('telegramId firstName telegramUsername downloadCount')
    .lean()
    .exec();

  const subDownloads = subs.reduce((sum, sub) => sum + (sub.downloadCount || 0), 0);
  const buyerOwn = buyer.downloadCount || 0;
  const archived = buyer.archivedSubDownloads || 0;
  const total = buyerOwn + subDownloads + archived;
  const { items: pageSubs, page: p, totalPages } = paginate(subs, 1);

  let text = 'üìä **YOUR ADMIN DASHBOARD**\n\n';
  text += `Admin: ${escMd(buyer.firstName) || 'N/A'} (@${escMd(buyer.telegramUsername) || 'N/A'})\n`;
  text += `ID: \`${buyer.telegramId}\`\n\n`;
  text += '**Work Summary:**\n';
  text += `Your Own PDFs: ${buyerOwn}\n`;
  text += `Your Users: ${subs.length}\n`;
  text += `Users' PDFs: ${subDownloads}\n`;
  text += `Total PDFs: ${total}\n\n`;
  text += `**Your Users** (Page ${p}/${totalPages})\n\n`;
  pageSubs.forEach((sub, i) => {
    text += `${(p - 1) * 10 + i + 1}. ${escMd(sub.firstName) || 'N/A'} (@${escMd(sub.telegramUsername) || 'N/A'})\n`;
    text += `   ID: \`${sub.telegramId}\`\n   PDFs: ${sub.downloadCount || 0}\n\n`;
  });

  const keyboard = [];
  // Only add pagination buttons if needed
  if (totalPages > 1) {
    const row = [];
    if (p > 1) row.push(Markup.button.callback('‚èÆÔ∏è Previous', `dashboard_buyer_page_${p - 1}`));
    if (p < totalPages) row.push(Markup.button.callback('‚è≠Ô∏è Next', `dashboard_buyer_page_${p + 1}`));
    keyboard.push(row);
  }

  if (isInline) {
    await ctx.editMessageText(text, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: keyboard } });
  } else {
    await ctx.reply(text, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: keyboard } });
  }
}

bot.action('dashboard_buyer', async (ctx) => {
  try {
    await ctx.answerCbQuery();
    await handleDashboard(ctx, true);
  } catch (error) {
    logger.error('Dashboard buyer error:', error);
    ctx.reply('‚ùå Failed to load dashboard. Please try again.').catch(() => { });
  }
});

bot.action(/dashboard_buyer_page_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    const page = parseInt(ctx.match[1], 10);
    const buyer = ctx.state.user;
    const subs = await User.find({ telegramId: { $in: buyer.subUsers || [] } })
      .select('telegramId firstName telegramUsername downloadCount')
      .lean()
      .exec();
    const subDownloads = subs.reduce((sum, sub) => sum + (sub.downloadCount || 0), 0);
    const buyerOwn = buyer.downloadCount || 0;
    const archived = buyer.archivedSubDownloads || 0;
    const total = buyerOwn + subDownloads + archived;
    const { items: pageSubs, page: p, totalPages } = paginate(subs, page);
    let text = 'üìä **YOUR ADMIN DASHBOARD**\n\n';
    text += `Admin: ${escMd(buyer.firstName) || 'N/A'} (@${escMd(buyer.telegramUsername) || 'N/A'})\n`;
    text += `ID: \`${buyer.telegramId}\`\n\n`;
    text += '**Work Summary:**\n';
    text += `Your Own PDFs: ${buyerOwn}\nYour Users: ${subs.length}\nUsers' PDFs: ${subDownloads}\nTotal PDFs: ${total}\n\n`;
    text += `**Your Users** (Page ${p}/${totalPages})\n\n`;
    pageSubs.forEach((sub, i) => {
      text += `${(p - 1) * 10 + i + 1}. ${escMd(sub.firstName) || 'N/A'} (@${escMd(sub.telegramUsername) || 'N/A'})\n`;
      text += `   ID: \`${sub.telegramId}\`\n   PDFs: ${sub.downloadCount || 0}\n\n`;
    });
    const keyboard = [];
    keyboard.push([Markup.button.callback('üë• Manage Users', 'manage_users')]);
    if (totalPages > 1) {
      const row = [];
      if (p > 1) row.push(Markup.button.callback('‚èÆÔ∏è Previous', `dashboard_buyer_page_${p - 1}`));
      if (p < totalPages) row.push(Markup.button.callback('‚è≠Ô∏è Next', `dashboard_buyer_page_${p + 1}`));
      keyboard.push(row);
    }
    await ctx.editMessageText(text, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: keyboard } });
  } catch (e) {
    logger.error('Dashboard buyer page error:', e);
    ctx.reply('‚ùå Failed.').catch(() => { });
  }
});

// ---------- Manage Users Handler (shared by inline button and reply keyboard) ----------
async function handleManageUsers(ctx, isInline) {
  const user = ctx.state.user;
  if (!user || !user.role) {
    return ctx.reply('‚ùå Session error. Send /start again.');
  }

  if (user.role === 'admin') {
    const title = 'üõ† **ADMIN USER MANAGEMENT**\n\n';
    const sub = `Admin: ${escMd(user.firstName) || 'N/A'} (@${escMd(user.telegramUsername) || 'N/A'})\nID: \`${user.telegramId}\`\n\n`;
    const keyboard = Markup.inlineKeyboard([
      [Markup.button.callback('üëÅ View My Users', 'view_my_users_page_1')],
      [Markup.button.callback('‚ûï Add User', 'add_sub_self')],
      [Markup.button.callback('üóë Remove User', 'remove_my_user_list_1')]
    ]);
    if (isInline) {
      try {
        await ctx.editMessageText(title + sub, { parse_mode: 'Markdown', ...keyboard });
      } catch (editErr) {
        logger.warn('manage_users editMessageText failed:', editErr.message);
        await ctx.reply(title + sub, { parse_mode: 'Markdown', ...keyboard });
      }
    } else {
      await ctx.reply(title + sub, { parse_mode: 'Markdown', ...keyboard });
    }
    return;
  }

  // Non-admin users shouldn't have this button, send welcome
  const title = getPanelTitle(user.role);
  await ctx.reply(title, { parse_mode: 'Markdown', ...getReplyKeyboard(user.role) });
}

bot.action('manage_users', async (ctx) => {
  try {
    await ctx.answerCbQuery();
    await handleManageUsers(ctx, true);
  } catch (error) {
    logger.error('Manage users error:', error?.message || error, error?.stack);
    try {
      ctx.reply('‚ùå Failed to load users. Please try again.').catch(() => { });
    } catch (_) { }
  }
});

// ---------- Admin: Add Buyer ----------
bot.action('add_buyer', async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    ctx.session = { ...ctx.session, step: 'AWAITING_BUYER_ID' };
    const keyboard = Markup.inlineKeyboard([[Markup.button.callback('üîô Cancel', 'manage_users')]]);
    await ctx.editMessageText(
      'üìù **Add Admin**\n\nSend the **Telegram ID** of the person (e.g. \`5434080792\`).\n\n_They must have sent /start first. Default 30 days access. Cancel to go back._',
      { parse_mode: 'Markdown', ...keyboard }
    );
  } catch (error) {
    logger.error('Add buyer error:', error);
    ctx.reply('‚ùå Failed. Please try again.').catch(() => { });
  }
});

// ---------- Admin: View Pending Users ----------
bot.action('view_pending', async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    const pending = await User.find({ role: 'unauthorized' })
      .sort({ lastActive: -1 })
      .limit(30)
      .select('telegramId firstName telegramUsername lastActive')
      .lean()
      .exec();

    let text = 'üìã **Pending Users** (sent /start, not added yet)\n\n';
    if (!pending.length) {
      text += 'No pending users.';
    } else {
      pending.forEach((u, i) => {
        const name = escMd(u.firstName) || escMd(u.telegramUsername) || u.telegramId;
        const uname = u.telegramUsername ? `@${escMd(u.telegramUsername)}` : '‚Äì';
        text += `${i + 1}. **${name}** (${uname})\n   ID: \`${u.telegramId}\`\n`;
      });
      text += `\n_Use Add Buyer and enter their Telegram ID to add them._`;
    }
    const keyboard = Markup.inlineKeyboard([
      [Markup.button.callback('‚ûï Add Admin', 'add_buyer')],
      [Markup.button.callback('üîô Back to Users', 'manage_users')]
    ]);
    await ctx.editMessageText(text, { parse_mode: 'Markdown', ...keyboard });
  } catch (error) {
    logger.error('View pending error:', error);
    ctx.reply('‚ùå Failed. Please try again.');
  }
});

// ---------- Admin: Manage a specific buyer ----------
bot.action(/select_admin_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    const adminId = ctx.match[1];
    const admin = await User.findOne({ telegramId: adminId }).lean();

    if (!admin) {
      return ctx.editMessageText('‚ùå User not found.', Markup.inlineKeyboard([
        [Markup.button.callback('üîô Back', 'manage_users')]
      ]));
    }

    const subs = await User.find({ telegramId: { $in: admin.subUsers || [] } })
      .select('telegramId firstName telegramUsername downloadCount')
      .lean()
      .exec();

    let text = `**Managing:** ${escMd(admin.firstName) || 'N/A'} (@${escMd(admin.telegramUsername) || 'N/A'})\n`;
    text += `ID: \`${admin.telegramId}\`\n`;
    text += `PDFs: ${admin.downloadCount || 0} | Users: ${subs.length}\n\n`;
    text += `**Sub‚ÄëUsers:**\n`;
    subs.forEach((sub, i) => {
      text += `${i + 1}. **${displayName(sub)}** (@${escMd(sub.telegramUsername) || 'N/A'})\n`;
      text += `   ID: \`${sub.telegramId}\` | PDFs: ${sub.downloadCount || 0}\n`;
    });

    const buttons = [
      [Markup.button.callback('‚ûï Add Sub‚ÄëUser', `add_sub_admin_${adminId}`)],
      [Markup.button.callback('‚ùå Remove Sub‚ÄëUser', `remove_sub_admin_${adminId}`)],
      [Markup.button.callback('üóë Remove Admin', `remove_buyer_${adminId}`)],
      [Markup.button.callback('üîô Back to Users', 'manage_users')]
    ];
    await ctx.editMessageText(text, {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: buttons }
    });
  } catch (error) {
    logger.error('Select admin error:', error);
    ctx.reply('‚ùå Failed to load user details. Please try again.').catch(() => { });
  }
});

// ---------- Admin: Add Sub‚ÄëUser ----------
bot.action(/add_sub_admin_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    const adminId = ctx.match[1];
    ctx.session = {
      ...ctx.session,
      step: 'AWAITING_SUB_IDENTIFIER',
      adminForAdd: adminId
    };
    const keyboard = Markup.inlineKeyboard([
      [Markup.button.callback('üîô Cancel', `cancel_add_sub_${adminId}`)]
    ]);
    await ctx.editMessageText(
      'üìù **Add Sub‚ÄëUser**\n\nSend the **Telegram ID** of the person (e.g. \`5434080792\`).\n\n_They must have sent /start to the bot first. Tap Cancel to go back._',
      { parse_mode: 'Markdown', ...keyboard }
    );
  } catch (error) {
    logger.error('Add sub admin error:', error);
    ctx.reply('‚ùå Failed. Please try again.').catch(() => { });
  }
});

// ---------- Admin: Remove Sub‚ÄëUser selection ----------
bot.action(/remove_sub_admin_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    const adminId = ctx.match[1];
    const admin = await User.findOne({ telegramId: adminId }).lean();
    const subs = await User.find({ telegramId: { $in: admin.subUsers || [] } })
      .select('telegramId firstName telegramUsername downloadCount')
      .lean()
      .exec();

    if (!subs.length) {
      return ctx.editMessageText('‚ùå This user has no sub‚Äëusers.', Markup.inlineKeyboard([
        [Markup.button.callback('üîô Back', `select_admin_${adminId}`)]
      ]));
    }

    let text = `**Select a sub‚Äëuser to remove from ${escMd(admin.firstName) || escMd(admin.telegramUsername) || adminId}:**\n\n`;
    const buttons = [];
    subs.forEach(sub => {
      const label = `${displayName(sub)} (PDFs: ${sub.downloadCount || 0})`;
      buttons.push([Markup.button.callback(`‚ùå ${label}`, `remove_sub_${adminId}_${sub.telegramId}`)]);
    });
    buttons.push([Markup.button.callback('üîô Back', `select_admin_${adminId}`)]);
    await ctx.editMessageText(text, {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: buttons }
    });
  } catch (error) {
    logger.error('Remove sub admin error:', error);
    ctx.reply('‚ùå Failed to load sub-users. Please try again.').catch(() => { });
  }
});

// ---------- Admin: Remove Buyer (demote to pending) ----------
bot.action(/remove_buyer_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    const buyerId = ctx.match[1];
    const buyer = await User.findOne({ telegramId: buyerId });
    if (!buyer) {
      return ctx.editMessageText('‚ùå User not found.', Markup.inlineKeyboard([[Markup.button.callback('üîô Back to Users', 'manage_users')]]));
    }
    // Archive sub-user downloads before demoting admin
    if (buyer.subUsers && buyer.subUsers.length > 0) {
      const subs = await User.find({ telegramId: { $in: buyer.subUsers } }).select('downloadCount').lean();
      const totalSubDl = subs.reduce((sum, s) => sum + (s.downloadCount || 0), 0);
      buyer.archivedSubDownloads = (buyer.archivedSubDownloads || 0) + totalSubDl;
    }
    buyer.role = 'unauthorized';
    buyer.addedBy = undefined;
    buyer.expiryDate = undefined;
    buyer.subUsers = [];
    await buyer.save();
    await User.updateMany({ addedBy: buyerId }, { role: 'unauthorized', addedBy: undefined, parentAdmin: undefined, expiryDate: undefined });
    await ctx.editMessageText(`‚úÖ Admin removed. They can be added again later.`, Markup.inlineKeyboard([
      [Markup.button.callback('üîô Back to Users', 'manage_users')]
    ]));
  } catch (error) {
    logger.error('Remove buyer error:', error);
    ctx.reply('‚ùå Failed. Please try again.').catch(() => { });
  }
});

// ---------- Admin: Execute removal ----------
bot.action(/remove_sub_(\d+)_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    if (!(await adminGuard(ctx))) return;
    const adminId = ctx.match[1];
    const subId = ctx.match[2];

    const admin = await User.findOne({ telegramId: adminId });
    if (!admin) {
      return ctx.editMessageText('‚ùå Admin not found.', Markup.inlineKeyboard([
        [Markup.button.callback('üîô Back to Users', 'manage_users')]
      ]));
    }

    // Archive sub-user downloads before deletion (atomic operation)
    const sub = await User.findOne({ telegramId: subId }).select('downloadCount').lean();
    const dlCount = sub?.downloadCount || 0;
    await User.findOneAndUpdate(
      { telegramId: adminId },
      { $pull: { subUsers: subId }, $inc: { archivedSubDownloads: dlCount } }
    );
    await User.deleteOne({ telegramId: subId });

    await ctx.editMessageText(`‚úÖ Sub‚Äëuser removed successfully.`, Markup.inlineKeyboard([
      [Markup.button.callback('üîô Back to Admin', `select_admin_${adminId}`)]
    ]));
  } catch (error) {
    logger.error('Remove sub error:', error);
    ctx.reply('‚ùå Failed to remove sub-user. Please try again.').catch(() => { });
  }
});

// ---------- Buyer: Manage Own Sub‚ÄëUsers ----------
bot.action('manage_subs', async (ctx) => {
  try {
    await ctx.answerCbQuery();
    const buyer = ctx.state.user;
    const subs = await User.find({ telegramId: { $in: buyer.subUsers || [] } })
      .select('telegramId firstName telegramUsername downloadCount')
      .lean()
      .exec();

    let text = 'üë• **Your Sub‚ÄëUsers**\n\n';
    if (!subs.length) {
      text += 'You have no sub‚Äëusers yet.';
    } else {
      subs.forEach((sub, i) => {
        text += `${i + 1}. **${displayName(sub)}** (@${escMd(sub.telegramUsername) || 'N/A'})\n`;
        text += `   ID: \`${sub.telegramId}\` | PDFs: ${sub.downloadCount || 0}\n`;
      });
    }

    const buttons = [
      [Markup.button.callback('‚ûï Add Sub‚ÄëUser', 'add_sub_self')]
    ];
    if (subs.length) {
      subs.forEach(sub => {
        buttons.push([Markup.button.callback(`‚ùå Remove ${displayName(sub)}`, `remove_my_sub_${sub.telegramId}`)]);
      });
    }
    buttons.push([Markup.button.callback('üîô Manage Users', 'manage_users')]);

    await ctx.editMessageText(text, {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: buttons }
    });
  } catch (error) {
    logger.error('Manage subs error:', error);
    ctx.reply('‚ùå Failed to load sub-users. Please try again.').catch(() => { });
  }
});

// ---------- Buyer: Add Sub‚ÄëUser (self) ----------
bot.action('add_sub_self', async (ctx) => {
  try {
    await ctx.answerCbQuery();
    ctx.session = { ...ctx.session, step: 'AWAITING_SUB_IDENTIFIER' };
    const keyboard = Markup.inlineKeyboard([
      [Markup.button.callback('üîô Cancel', 'cancel_add_sub')]
    ]);
    await ctx.editMessageText(
      'üìù **Add Sub‚ÄëUser**\n\nSend the **Telegram ID** of the person (e.g. \`5434080792\`).\n\n_They must have sent /start to the bot first. Tap Cancel to go back._',
      { parse_mode: 'Markdown', ...keyboard }
    );
  } catch (error) {
    logger.error('Add sub self error:', error);
    ctx.reply('‚ùå Failed. Please try again.').catch(() => { });
  }
});

// ---------- Cancel Add Sub (go back to Manage Users screen) ----------
bot.action('cancel_add_sub', async (ctx) => {
  try {
    await ctx.answerCbQuery();
    ctx.session = ctx.session || {}; ctx.session.step = null;
    await handleManageUsers(ctx, true);
  } catch (error) {
    logger.error('Cancel add sub error:', error);
  }
});

bot.action(/cancel_add_sub_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    const adminId = ctx.match[1];
    ctx.session = ctx.session || {}; ctx.session.step = null;
    const admin = await User.findOne({ telegramId: adminId }).lean();
    if (!admin) {
      return ctx.editMessageText('‚ùå Cancelled. Admin no longer found.');
    }
    const subs = await User.find({ telegramId: { $in: admin.subUsers || [] } })
      .select('telegramId firstName telegramUsername downloadCount')
      .lean()
      .exec();
    let text = `** Managing:** ${escMd(admin.firstName) || 'N/A'} (@${escMd(admin.telegramUsername) || 'N/A'}) \n`;
    text += `ID: \`${admin.telegramId}\`\n`;
    text += `PDFs: ${admin.downloadCount || 0} | Users: ${subs.length}\n\n`;
    text += `**Sub‚ÄëUsers:**\n`;
    subs.forEach((sub, i) => {
      text += `${i + 1}. **${displayName(sub)}** (@${escMd(sub.telegramUsername) || 'N/A'})\n`;
      text += `   ID: \`${sub.telegramId}\` | PDFs: ${sub.downloadCount || 0}\n`;
    });
    const buttons = [
      [Markup.button.callback('‚ûï Add Sub‚ÄëUser', `add_sub_admin_${adminId}`)],
      [Markup.button.callback('‚ùå Remove Sub‚ÄëUser', `remove_sub_admin_${adminId}`)],
      [Markup.button.callback('üîô Back to Users', 'manage_users')]
    ];
    await ctx.editMessageText(text, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: buttons } });
  } catch (e) {
    logger.error('Cancel add sub admin error:', e);
  }
});

// ---------- Buyer: Remove Own Sub‚ÄëUser ----------
bot.action(/remove_my_sub_(\d+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    const subId = ctx.match[1];
    const buyer = ctx.state.user;

    // Archive sub-user downloads before deletion (atomic operation)
    const sub = await User.findOne({ telegramId: subId }).select('downloadCount').lean();
    const dlCount = sub?.downloadCount || 0;
    await User.findOneAndUpdate(
      { telegramId: buyer.telegramId },
      { $pull: { subUsers: subId }, $inc: { archivedSubDownloads: dlCount } }
    );
    await User.deleteOne({ telegramId: subId });

    await ctx.editMessageText(`‚úÖ Sub‚Äëuser removed.`, Markup.inlineKeyboard([
      [Markup.button.callback('üë• Manage Sub‚ÄëUsers', 'manage_subs')]
    ]));
  } catch (error) {
    logger.error('Remove my sub error:', error);
    ctx.reply('‚ùå Failed to remove sub-user. Please try again.').catch(() => { });
  }
});

// ---------- Text Handler ‚Äì Reply Keyboard Routing & Download Flow & Add Sub‚ÄëUser ----------
bot.on('text', async (ctx) => {
  try {
    const text = ctx.message.text.trim();
    const state = ctx.session;

    // --- Reply Keyboard button routing (context-aware download lock) ---
    const userId = ctx.from.id.toString();
    const hasActiveDownload = activeDownloads.has(userId);

    if (text === BTN.MANAGE || text === BTN.DASHBOARD) {
      // Non-download menus: auto-cancel any active download, then show menu
      if (hasActiveDownload) {
        activeDownloads.delete(userId);
        ctx.session = ctx.session || {};
        ctx.session.step = null;
        await ctx.reply('‚ùå Download Cancelled.');
      }
      ctx.session = ctx.session || {};
      ctx.session.step = null;
      if (text === BTN.MANAGE) {
        return handleManageUsers(ctx, false);
      } else {
        try {
          return await handleDashboard(ctx, false);
        } catch (e) {
          logger.error('Dashboard from keyboard error:', e);
          return ctx.reply('‚ùå Failed to load dashboard.');
        }
      }
    }

    if (text === BTN.START) {
      if (hasActiveDownload) {
        // During OTP step: remind user to enter OTP
        if (state && state.step === 'OTP') {
          return ctx.reply('‚è≥ You already have a download in progress.\nEnter the OTP sent to your phone:\n_Send /cancel to return to menu._', { parse_mode: 'Markdown' });
        }
        // During other download steps (captcha/verification): just block
        return ctx.reply('‚è≥ You already have a download in progress. Please wait.\n_Send /cancel to return to menu._', { parse_mode: 'Markdown' });
      }
      ctx.session = ctx.session || {};
      ctx.session.step = null;
      return handleDownload(ctx, false);
    }

    // --- Flow step processing ---
    if (!state || !state.step) {
      return;
    }

    // ----- Add Buyer Flow (Admin) -----
    if (state.step === 'AWAITING_BUYER_ID') {
      const telegramId = text.trim().replace(/\s/g, '');
      if (!/^\d+$/.test(telegramId)) {
        return ctx.reply('‚ùå Please enter a numeric Telegram ID (e.g. 5434080792).');
      }
      const statusMsg = await ctx.reply('üîç Looking up user...');
      try {
        let user = await User.findOne({ telegramId });
        if (!user) {
          ctx.session = ctx.session || {}; ctx.session.step = null;
          return ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
            '‚ö†Ô∏è This user hasn\'t started the bot yet. Ask them to send /start first.'
          );
        }
        if (user.role === 'admin') {
          ctx.session = ctx.session || {}; ctx.session.step = null;
          return ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
            '‚ùå This user is already an admin.'
          );
        }
        if (user.addedBy) {
          await User.updateOne({ telegramId: user.addedBy }, { $pull: { subUsers: user.telegramId } });
        }
        const expiryDate = new Date();
        expiryDate.setDate(expiryDate.getDate() + 30);
        user.role = 'admin';
        user.addedBy = undefined;
        user.expiryDate = expiryDate;
        user.subUsers = [];
        await user.save();
        ctx.session = ctx.session || {}; ctx.session.step = null;
        await ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
          `‚úÖ **${displayName(user)}** added as admin (30 days).`,
          { parse_mode: 'Markdown' }
        );
        try {
          await bot.telegram.sendMessage(user.telegramId, "‚úÖ Your access has been activated!", { parse_mode: 'Markdown' });
          await bot.telegram.sendMessage(user.telegramId, getPanelTitle('admin'), { parse_mode: 'Markdown', ...getReplyKeyboard('admin') });
        } catch (e) {
          logger.warn('Could not send menu to new admin:', e.message);
        }
      } catch (error) {
        logger.error('Add buyer error:', error);
        ctx.session = ctx.session || {}; ctx.session.step = null;
        ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
          '‚ùå Failed to add buyer. Please try again.'
        ).catch(() => {
          ctx.reply('‚ùå Failed to add buyer. Please try again.');
        });
      }
      return;
    }

    // ----- Add User Under Admin: step 1 ‚Äì admin ID -----
    if (state.step === 'AWAITING_ADMIN_ID_FOR_USER') {
      const adminId = text.trim().replace(/\s/g, '');
      if (!/^\d+$/.test(adminId)) {
        return ctx.reply('‚ùå Please enter a numeric Telegram ID for the admin.');
      }
      const admin = await User.findOne({ telegramId: adminId, role: 'admin' });
      if (!admin) {
        return ctx.reply('‚ùå No admin found with that ID. They must already be an admin.');
      }
      ctx.session.step = 'AWAITING_USER_ID_UNDER_ADMIN';
      ctx.session.adminIdForUser = adminId;
      await ctx.reply(
        `‚úÖ Admin found: ${escMd(admin.firstName) || escMd(admin.telegramUsername) || adminId}.\n\nNow send the **Telegram ID** of the **user** to add under this admin.`,
        { parse_mode: 'Markdown', ...Markup.inlineKeyboard([[Markup.button.callback('üîô Cancel', 'manage_users')]]) }
      );
      return;
    }

    // ----- Add User Under Admin: step 2 ‚Äì user ID, then confirm and save -----
    if (state.step === 'AWAITING_USER_ID_UNDER_ADMIN') {
      const userId = text.trim().replace(/\s/g, '');
      if (!/^\d+$/.test(userId)) {
        return ctx.reply('‚ùå Please enter a numeric Telegram ID for the user.');
      }
      const adminId = state.adminIdForUser;
      const statusMsg = await ctx.reply('üîç Looking up user...');
      try {
        const admin = await User.findOne({ telegramId: adminId });
        if (!admin) {
          ctx.session = ctx.session || {}; ctx.session.step = null;
          return ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
            '‚ùå Admin no longer found. Cancelled.'
          );
        }
        const targetUser = await User.findOne({ telegramId: userId });
        if (!targetUser) {
          return ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
            '‚ùå That user has not started the bot yet. Ask them to send /start first.'
          );
        }
        if (targetUser.role === 'admin') {
          return ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
            '‚ùå That ID belongs to an admin. Choose a regular user.'
          );
        }
        if ((admin.subUsers || []).includes(userId)) {
          ctx.session = ctx.session || {}; ctx.session.step = null;
          return ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
            '‚ùå This user is already under this admin.'
          );
        }
        if ((admin.subUsers || []).length >= 9) {
          return ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
            '‚ùå This admin already has 9 users.'
          );
        }
        if (targetUser.addedBy) {
          await User.updateOne({ telegramId: targetUser.addedBy }, { $pull: { subUsers: userId } });
        }
        admin.subUsers = admin.subUsers || [];
        admin.subUsers.push(userId);
        await admin.save();
        targetUser.role = 'user';
        targetUser.addedBy = adminId;
        targetUser.parentAdmin = adminId;
        targetUser.expiryDate = admin.expiryDate;
        await targetUser.save();
        ctx.session = ctx.session || {}; ctx.session.step = null;
        await ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
          `‚úÖ **${escMd(targetUser.firstName) || targetUser.telegramId}** added under admin **${escMd(admin.firstName) || adminId}**.`,
          { parse_mode: 'Markdown' }
        );
        try {
          await bot.telegram.sendMessage(userId, "‚úÖ Your access has been activated!", { parse_mode: 'Markdown' });
          await bot.telegram.sendMessage(userId, getPanelTitle('user'), { parse_mode: 'Markdown', ...getReplyKeyboard('user') });
        } catch (e) {
          logger.warn('Could not send activation to user:', e.message);
        }
      } catch (error) {
        logger.error('Add user under admin error:', error);
        ctx.session = ctx.session || {}; ctx.session.step = null;
        ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
          '‚ùå Failed to add user. Please try again.'
        ).catch(() => {
          ctx.reply('‚ùå Failed to add user. Please try again.');
        });
      }
      return;
    }

    // ----- Add Sub‚ÄëUser Flow -----
    if (state.step === 'AWAITING_SUB_IDENTIFIER') {
      const buyerId = state.adminForAdd || ctx.from.id.toString();
      const buyer = await User.findOne({ telegramId: buyerId });

      if (!buyer) {
        ctx.session = ctx.session || {}; ctx.session.step = null;
        return ctx.reply('‚ùå Buyer not found. Please try again.');
      }

      const telegramId = text.trim().replace(/\s/g, '');
      if (!/^\d+$/.test(telegramId)) {
        return ctx.reply('‚ùå Please enter a numeric Telegram ID (e.g. 5434080792).');
      }

      const statusMsg = await ctx.reply('üîç Looking up user...');

      try {
        let subUser = await User.findOne({ telegramId });
        if (!subUser) {
          ctx.session = ctx.session || {}; ctx.session.step = null;
          return ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
            "‚ö†Ô∏è This user hasn't started the bot yet.\n\nAsk them to send /start to the bot first."
          );
        }

        if ((buyer.subUsers || []).length >= 9) {
          ctx.session = ctx.session || {}; ctx.session.step = null;
          return ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
            '‚ùå This buyer already has 9 employees.'
          );
        }
        if ((buyer.subUsers || []).includes(subUser.telegramId)) {
          ctx.session = ctx.session || {}; ctx.session.step = null;
          return ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
            '‚ùå This user is already an employee of this buyer.'
          );
        }

        buyer.subUsers = buyer.subUsers || [];
        buyer.subUsers.push(subUser.telegramId);
        await buyer.save();

        subUser.role = 'user';
        subUser.addedBy = buyer.telegramId;
        subUser.parentAdmin = buyer.telegramId;
        subUser.expiryDate = buyer.expiryDate;
        await subUser.save();

        ctx.session = ctx.session || {}; ctx.session.step = null;
        await ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
          '‚úÖ User added successfully!'
        );
        try {
          await bot.telegram.sendMessage(subUser.telegramId, "‚úÖ Your access has been activated!", { parse_mode: 'Markdown' });
          await bot.telegram.sendMessage(subUser.telegramId, getPanelTitle('user'), { parse_mode: 'Markdown', ...getReplyKeyboard('user') });
        } catch (e) {
          logger.warn('Could not send menu to new user:', e.message);
        }
      } catch (error) {
        logger.error('Add sub error:', error);
        ctx.session = ctx.session || {}; ctx.session.step = null;
        ctx.telegram.editMessageText(ctx.chat.id, statusMsg.message_id, null,
          '‚ùå Failed to add employee. Please try again.'
        ).catch(() => {
          ctx.reply('‚ùå Failed to add employee. Please try again.');
        });
      }
      return;
    }

    // ----- Download Flow: ID Step -----
    if (state.step === 'ID') {
      const validation = validateFaydaId(text);
      if (!validation.valid) {
        return ctx.reply(`‚ùå ${validation.error}`, { parse_mode: 'Markdown' });
      }

      const userId = ctx.from.id.toString();

      // Per-user download lock ‚Äî reject if already downloading
      if (activeDownloads.has(userId)) {
        return ctx.reply('‚è≥ You already have a download in progress. Please wait.');
      }

      // Verification cooldown ‚Äî prevent OTP flood on Fayda API
      const lastFail = verificationCooldown.get(userId);
      if (lastFail && (Date.now() - lastFail) < VERIFICATION_COOLDOWN_MS) {
        const waitSec = Math.ceil((VERIFICATION_COOLDOWN_MS - (Date.now() - lastFail)) / 1000);
        return ctx.reply(`‚è≥ Please wait ${waitSec} seconds before trying again.`);
      }

      activeDownloads.set(userId, true);

      const timer = new DownloadTimer(userId);
      const status = await ctx.reply("‚è≥ Loading...");

      let verified = false;
      let lastErr;
      let apiWasCalled = false; // Only set cooldown if we actually hit the Fayda API
      for (let attempt = 1; attempt <= CAPTCHA_VERIFY_ATTEMPTS && !verified; attempt++) {
        // Cancel-aware: if session step was cleared (e.g. /cancel), abort
        if (!ctx.session || ctx.session.step !== 'ID') {
          logger.info('Download cancelled by user during ID verification');
          activeDownloads.delete(userId);
          return;
        }
        try {
          timer.startStep('captchaSolve');
          // Use pre-solved captcha from handleDownload if available, else solve fresh
          let captchaToken = null;
          if (attempt === 1 && pendingCaptchas.has(userId)) {
            captchaToken = await pendingCaptchas.get(userId);
            pendingCaptchas.delete(userId);
          }
          if (!captchaToken) {
            // Fallback: solve on-demand (pre-solve failed or this is a retry)
            const result = await solver.recaptcha(SITE_KEY, 'https://resident.fayda.et/');
            captchaToken = result.data;
          }
          timer.endStep('captchaSolve');

          timer.startStep('idVerification');
          apiWasCalled = true; // Mark that we're about to call the provider
          const res = await fayda.api.post('/verify', {
            idNumber: validation.value,
            verificationMethod: validation.type || 'FCN',
            captchaValue: captchaToken
          }, { timeout: 35000 });
          timer.endStep('idVerification');

          // Success ‚Äî clear cooldown
          verificationCooldown.delete(userId);

          ctx.session.tempJwt = res.data.token;
          ctx.session.id = validation.value;
          ctx.session.verificationMethod = validation.type || 'FCN';
          ctx.session.step = 'OTP';
          verified = true;

          // Record ID phase duration and persist timer for OTP step
          timer.setPhase('idPhaseMs', Date.now() - timer.flowStart);
          ctx.session._timer = timer.toSession();

          await ctx.telegram.editMessageText(ctx.chat.id, status.message_id, null, "Enter the OTP sent to your phone:\n_Send /cancel to return to menu._", { parse_mode: 'Markdown' });
          // Keep download lock ‚Äî will be released after OTP step completes
        } catch (e) {
          timer.endStep('captchaSolve');   // no-op if already ended
          timer.endStep('idVerification'); // no-op if not started
          lastErr = e;
          const errMsg = e.response?.data?.message || e.message || 'Verification failed';
          logger.warn(`ID verification attempt ${attempt}/${CAPTCHA_VERIFY_ATTEMPTS} failed`, { error: errMsg });

          // Smart retry: only retry on server errors (5xx) ‚Äî abort on client errors (4xx)
          const status4xx = e.response?.status >= 400 && e.response?.status < 500;
          if (status4xx) {
            logger.warn('ID verification returned 4xx, aborting retries', { status: e.response?.status });
            break;
          }
        }
      }
      if (!verified) {
        activeDownloads.delete(userId);
        // Only set cooldown if we actually reached the Fayda API (not captcha failure or internal error)
        if (apiWasCalled) verificationCooldown.set(userId, Date.now());
        const rawMsg = lastErr?.response?.data?.message || lastErr?.message || '';
        const userMsg = /too many|limit|wait/i.test(rawMsg)
          ? '‚è≥ Too many attempts. Please wait a few minutes before trying again.'
          : /invalid/i.test(rawMsg) ? '‚ùå Invalid ID. Please check and try again.'
            : `‚ùå Verification failed. Please try /start again.`;
        logger.error("ID verification error after retries:", { error: rawMsg, stack: lastErr?.stack });
        timer.report('id_verification_failed');
        ctx.reply(userMsg);
        ctx.session = ctx.session || {}; ctx.session.step = null;
      }
      return;
    }

    // ----- Download Flow: OTP Step -----
    if (state.step === 'OTP') {
      // Prevent duplicate processing
      if (state.processingOTP) {
        return; // Already processing, ignore duplicate
      }
      state.processingOTP = true;
      const userId = ctx.from.id.toString();

      const validation = validateOTP(text);
      if (!validation.valid) {
        state.processingOTP = false;
        return ctx.reply(`‚ùå ${validation.error}. Please enter a valid OTP.`);
      }

      // Restore timer from ID phase (single requestId across entire flow)
      const timer = DownloadTimer.fromSession(state._timer, ctx.from.id.toString());
      const otpPhaseStart = Date.now();
      // User wait = time between ID phase end and OTP submission
      if (state._timer?.flowStart) {
        const idPhaseEnd = (state._timer.flowStart || 0) + (state._timer.phaseTimings?.idPhaseMs || 0);
        timer.setPhase('userWaitMs', otpPhaseStart - idPhaseEnd);
      }

      const status = await ctx.reply("‚è≥ Verifying OTP and generating document...");
      const authHeader = { ...HEADERS, 'Authorization': `Bearer ${state.tempJwt}` };

      let otpResponse;
      let otpAttempts = 2;
      timer.startStep('otpValidation');
      for (let attempt = 1; attempt <= otpAttempts; attempt++) {
        try {
          otpResponse = await fayda.api.post('/validateOtp', {
            otp: validation.value,
            uniqueId: state.id,
            verificationMethod: state.verificationMethod || 'FCN'
          }, {
            headers: authHeader,
            timeout: 35000
          });
          break;
        } catch (e) {
          const isRetryable = !e.response || (e.response.status >= 500 && e.response.status < 600) || ['ECONNABORTED', 'ETIMEDOUT', 'ECONNRESET'].includes(e.code);
          if (attempt === otpAttempts || !isRetryable) throw e;
          logger.warn(`validateOtp attempt ${attempt} failed, retrying`, { error: e.message });
          await new Promise(r => setTimeout(r, 2000));
        }
      }
      timer.endStep('otpValidation');

      try {
        const { signature, uin, fullName } = otpResponse.data;
        if (!signature || !uin) {
          throw new Error('Missing signature or uin in OTP response');
        }

        await ctx.telegram.editMessageText(ctx.chat.id, status.message_id, null, "‚è≥ OTP Verified. Fetching ID file...");

        // Under heavy load (PREFER_QUEUE_PDF=true) skip sync and always queue for controlled concurrency
        let pdfSent = false;
        let lastSyncError;
        if (!PREFER_QUEUE_PDF) {
          for (let attempt = 1; attempt <= PDF_SYNC_ATTEMPTS && !pdfSent; attempt++) {
            // Cancel-aware: if session was cleared (e.g. /cancel), abort
            if (!ctx.session || ctx.session.step !== 'OTP') {
              logger.info('Download cancelled by user during PDF fetch');
              activeDownloads.delete(userId);
              return;
            }
            try {
              timer.startStep('pdfFetch');
              const pdfResponse = await fayda.api.post('/printableCredentialRoute', { uin, signature }, {
                headers: authHeader,
                responseType: 'text',
                timeout: 25000
              });
              timer.endStep('pdfFetch');

              timer.startStep('pdfConversion');
              const { buffer: pdfBuffer } = parsePdfResponse(pdfResponse.data);
              timer.endStep('pdfConversion');

              const safeName = (fullName?.eng || 'Fayda_Card').replace(/[^a-zA-Z0-9]/g, '_');
              const filename = `${safeName}.pdf`;

              timer.startStep('telegramUpload');
              await ctx.replyWithDocument({
                source: pdfBuffer,
                filename: filename
              }, { caption: "‚ú® Your Digital ID is ready!" });
              timer.endStep('telegramUpload');

              await User.updateOne(
                { telegramId: userId },
                { $inc: { downloadCount: 1 }, $set: { lastDownload: new Date() } }
              );
              ctx.session = ctx.session || {}; ctx.session.step = null;
              activeDownloads.delete(userId);
              pdfSent = true;
            } catch (syncErr) {
              timer.endStep('pdfFetch');      // no-op if already ended
              timer.endStep('pdfConversion'); // no-op if not started
              timer.endStep('telegramUpload');
              lastSyncError = syncErr;

              // 400 = session/token invalid ‚Äî abort immediately, no point retrying
              const status4xx = syncErr.response?.status >= 400 && syncErr.response?.status < 500;
              if (status4xx) {
                logger.warn('PDF fetch returned 4xx, aborting', { status: syncErr.response?.status, error: syncErr.message });
                break; // skip to queue/failure path
              }

              if (attempt < PDF_SYNC_ATTEMPTS) {
                logger.warn(`Sync PDF attempt ${attempt} failed, retrying`, { error: syncErr.message });
                // Show user one clean message ‚Äî no attempt counts
                await ctx.telegram.editMessageText(ctx.chat.id, status.message_id, null, "‚è≥ Please wait‚Ä¶ processing your document.").catch(() => { });
                await new Promise(r => setTimeout(r, PDF_SYNC_RETRY_DELAY_MS));
              }
            }
          }
        }

        if (pdfSent) {
          timer.setPhase('otpPhaseMs', Date.now() - otpPhaseStart);
          timer.report('success');
        } else {
          // Sync failed (or PREFER_QUEUE_PDF) ‚Äî enqueue for background retries
          try {
            const job = await pdfQueue.add({
              chatId: ctx.chat.id,
              userId: ctx.from.id.toString(),
              userRole: ctx.state.user?.role || 'user',
              authHeader,
              pdfPayload: { uin, signature },
              fullName,
              _timer: timer.toSession()
            }, {
              priority: 1,
              timeout: 60000
            });
            logger.info(`PDF job ${job.id} queued (sync failed) for user ${ctx.from.id.toString()}`);
          } catch (queueError) {
            logger.error('Queue add failed, trying sync once more:', queueError);
            await ctx.telegram.editMessageText(ctx.chat.id, status.message_id, null, "‚è≥ Processing PDF directly...");
            try {
              timer.startStep('pdfFetch');
              const pdfResponse = await fayda.api.post('/printableCredentialRoute', { uin, signature }, {
                headers: authHeader,
                responseType: 'text',
                timeout: 25000
              });
              timer.endStep('pdfFetch');

              timer.startStep('pdfConversion');
              const { buffer: pdfBuffer } = parsePdfResponse(pdfResponse.data);
              timer.endStep('pdfConversion');

              const safeName = (fullName?.eng || 'Fayda_Card').replace(/[^a-zA-Z0-9]/g, '_');

              timer.startStep('telegramUpload');
              await ctx.replyWithDocument({
                source: pdfBuffer,
                filename: `${safeName}.pdf`
              }, { caption: "‚ú® Your Digital ID is ready!" });
              timer.endStep('telegramUpload');

              await User.updateOne(
                { telegramId: ctx.from.id.toString() },
                { $inc: { downloadCount: 1 }, $set: { lastDownload: new Date() } }
              );
              ctx.session = ctx.session || {}; ctx.session.step = null;
              activeDownloads.delete(userId);
              pdfSent = true;
              timer.setPhase('otpPhaseMs', Date.now() - otpPhaseStart);
              timer.report('success_after_queue_fallback');
            } catch (syncError2) {
              timer.endStep('pdfFetch');
              timer.endStep('pdfConversion');
              timer.endStep('telegramUpload');
              logger.error('Synchronous PDF processing failed:', {
                error: syncError2.message,
                response: safeResponseForLog(syncError2.response?.data)
              });
              timer.setPhase('otpPhaseMs', Date.now() - otpPhaseStart);
              timer.report('failed');
              await ctx.reply('‚ùå Download failed. Please try /start again.');
              ctx.session = ctx.session || {}; ctx.session.step = null;
              activeDownloads.delete(userId);
            }
          }

          // Only show "queued" message if we didn't send PDF (queue was used)
          if (!pdfSent) {
            timer.setPhase('otpPhaseMs', Date.now() - otpPhaseStart);
            timer.report('queued');
            ctx.session = ctx.session || {}; ctx.session.step = null;
            activeDownloads.delete(userId);
            await ctx.reply('‚úÖ Your request has been queued. You will receive your PDF shortly.');
          }
        }
      } catch (e) {
        timer.endStep('otpValidation'); // end if still open
        logger.error("OTP/PDF Error:", {
          error: e.message,
          stack: e.stack,
          response: safeResponseForLog(e.response?.data)
        });
        timer.setPhase('otpPhaseMs', Date.now() - otpPhaseStart);
        timer.report('failed');
        try {
          await ctx.reply(`‚ùå Failed: ${e.response?.data?.message || e.message || 'Unknown error. Please try again.'}`);
        } catch (replyError) {
          logger.error('Failed to send error message:', replyError);
        }
        ctx.session = ctx.session || {}; ctx.session.step = null;
        activeDownloads.delete(userId);
      } finally {
        // Always clear processing flag
        if (state) {
          state.processingOTP = false;
        }
      }
      return;
    }
  } catch (error) {
    logger.error('Text handler error:', {
      message: error.message,
      stack: error.stack,
      status: error.response?.status,
      response: safeResponseForLog(error.response?.data)
    });
    activeDownloads.delete(ctx.from?.id?.toString());
    ctx.reply('‚ùå An error occurred. Please try again.').catch(() => { });
  }
});

// ---------- Graceful Shutdown ----------
async function gracefulShutdown(signal) {
  logger.info(`${signal} received, starting graceful shutdown...`);

  try {
    // bot.stop() only works with polling (bot.launch()), not webhooks
    // In webhook mode the bot is not "running" so stop() throws
    try { await bot.stop(signal); } catch (_) { /* webhook mode ‚Äî ignore */ }

    await disconnectDB();
    await pdfQueue.close();
    process.exit(0);
  } catch (error) {
    logger.error('Error during shutdown:', { message: error.message, stack: error.stack });
    process.exit(1);
  }
}

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// ---------- Start Server ----------
async function startServer() {
  try {
    // Connect to database
    await connectDB();
    await migrateRoles();


    // Set webhook
    const webhookPath = '/webhook';
    // Ensure WEBHOOK_DOMAIN has https:// prefix
    let webhookDomain = process.env.WEBHOOK_DOMAIN || '';
    if (webhookDomain && !webhookDomain.startsWith('http')) {
      webhookDomain = `https://${webhookDomain}`;
      logger.warn(`‚ö†Ô∏è WEBHOOK_DOMAIN missing protocol, added https://`);
    }
    const webhookUrl = `${webhookDomain}${webhookPath}`;
    await bot.telegram.setWebhook(webhookUrl);
    app.use(bot.webhookCallback(webhookPath));

    // Warn if WEBHOOK_DOMAIN looks like a placeholder
    if (/your-app-name|example\.com|localhost/.test(process.env.WEBHOOK_DOMAIN || '')) {
      logger.warn('‚ö†Ô∏è WEBHOOK_DOMAIN looks like a placeholder. Update it in your deployment Variables to your real URL (e.g. https://fayda-bot.onrender.com) or the bot will not receive messages.');
    }

    const PORT = process.env.PORT || 3000;
    app.listen(PORT, () => {
      logger.info(`üöÄ Server running on port ${PORT}`);
      logger.info(`ü§ñ Webhook active at ${webhookUrl}`);
    });
  } catch (err) {
    logger.error("‚ùå Failed to start server:", err);
    process.exit(1);
  }
}

startServer();
